<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Obby 3D — Mini</title>

  <!-- Social preview -->
  <meta property="og:title" content="Obby 3D — Mini" />
  <meta property="og:description" content="Tap/Space to jump across floating platforms. How far can you go?" />
  <meta property="og:image" content="https://zux12.github.io/whatsapp-mini-game/preview.png" />
  <meta property="og:url" content="https://zux12.github.io/whatsapp-mini-game/" />
  <meta name="twitter:card" content="summary_large_image" />

  <link rel="icon" href="favicon.ico" />

  <style>
    :root { --bg:#0e1024; --fg:#e9ecff; --muted:#8b90b6; --accent:#69e08a; }
    html,body{height:100%; margin:0; background:radial-gradient(120vmax 120vmax at 50% -20%, #161a3a, var(--bg) 55%); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial,sans-serif; overflow:hidden;}
    [hidden]{ display:none !important; }

    #hud{
      position:fixed; inset:0; pointer-events:none; display:flex; flex-direction:column; justify-content:space-between;
      padding:12px;
    }
    .topbar{display:flex; gap:8px; align-items:center; justify-content:space-between;}
    .pill{pointer-events:auto; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); padding:8px 12px; border-radius:999px; font-variant-numeric:tabular-nums;}
    .btn{pointer-events:auto; border:0; padding:12px 16px; border-radius:12px; cursor:pointer; font-weight:700; background:var(--accent); color:#072114; box-shadow:0 10px 24px rgba(106,224,138,.35);}
    .btn.secondary{background:#2d335e; color:#dfe3ff; box-shadow:none}

    #overlay{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:linear-gradient(180deg, rgba(10,12,30,.72), rgba(10,12,30,.55));
      backdrop-filter: blur(4px);
      z-index: 10;
    }
    .card{
      width:min(92vw,540px); border-radius:20px; padding:16px; text-align:center;
      background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12);
      box-shadow:0 20px 60px rgba(0,0,0,0.45);
    }
    h1{margin:8px 0 6px; font-size:22px}
    p{margin:8px 0; color:var(--muted)}
    .row{display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:10px}
    #hint{font-size:13px}
  </style>
</head>
<body>
  <div id="hud">
    <div class="topbar">
      <div class="pill">Score: <b id="score">0</b></div>
      <div class="pill">Best: <b id="best">0</b></div>
      <div class="pill">Tap/Space = Jump</div>
    </div>
    <div style="display:flex; gap:8px; justify-content:center; margin-bottom:10px;">
      <button id="shareBtn" class="btn secondary">Share my score</button>
    </div>
  </div>

  <div id="overlay">
    <div class="card">
      <h1>Obby 3D — Mini</h1>
      <p id="summary">Jump across floating platforms. Don’t fall!</p>
      <div class="row">
        <button id="playBtn" class="btn">▶️ Play</button>
        <button id="restartBtn" class="btn" style="display:none">↻ Restart</button>
        <button id="howBtn" class="btn secondary">How to play</button>
      </div>
      <p id="hint">Tap anywhere or press Space to jump. Reach farther platforms to gain score.</p>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

    // ------- Scene -------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0d1023);
    scene.fog = new THREE.Fog(0x0d1023, 30, 120);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 4.5, 10);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const hemi = new THREE.HemisphereLight(0xcad8ff, 0x202535, 1.2);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5,8,2);
    scene.add(dir);

    // Ground ambience
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(400, 400),
      new THREE.MeshPhongMaterial({ color: 0x12183a, shininess: 10, specular: 0x0 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -20;
    scene.add(ground);

    // ------- Player: Blockman -------
    const playerGroup = new THREE.Group();

    // Palette
    const torsoCol = 0x38e1b6;   // teal
    const legCol   = 0x8b6cff;   // purple
    const armCol   = 0xffa24d;   // orange
    const headCol  = 0xfff1cc;   // warm cream
    const hairCol  = 0x1b2038;   // dark hair
    const backEye  = 0x99a3ff;   // soft blue back-eyes

    // Body
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.0, 0.4),
      new THREE.MeshStandardMaterial({ color: torsoCol, roughness: 0.45, metalness: 0.08 }));
    body.position.y = 0.8;

    // Head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5),
      new THREE.MeshStandardMaterial({ color: headCol, roughness: 0.55, metalness: 0.05 }));
    head.position.y = 1.35;

    // Front face eyes
    const eyeMatFront = new THREE.MeshStandardMaterial({ color: 0x1c2038, roughness: 0.4, metalness: 0.1 });
    const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.07, 0.07), eyeMatFront);
    const eyeR = eyeL.clone();
    eyeL.position.set(-0.12, 1.40, 0.26);
    eyeR.position.set( 0.12, 1.40, 0.26);

    // Hair cap (back/top) + hair stripe
    const hairCap = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.28, 0.32),
      new THREE.MeshStandardMaterial({ color: hairCol, roughness: 0.6, metalness: 0.08 }));
    hairCap.position.set(0, 1.46, -0.05);

    const hairStripe = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.06, 0.4),
      new THREE.MeshStandardMaterial({ color: hairCol, roughness: 0.6, metalness: 0.08 }));
    hairStripe.position.set(0, 1.52, -0.02);

    // Back-of-head “eyes” tucked under hair (fun detail)
    const backEyeMat = new THREE.MeshStandardMaterial({ color: backEye, roughness: 0.35, metalness: 0.15 });
    const backEyeL = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.06), backEyeMat);
    const backEyeR = backEyeL.clone();
    backEyeL.position.set(-0.12, 1.40, -0.26);
    backEyeR.position.set( 0.12, 1.40, -0.26);

    // Arms
    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.7, 0.18),
      new THREE.MeshStandardMaterial({ color: armCol, roughness: 0.45, metalness: 0.08 }));
    const armR = armL.clone();
    armL.position.set(-0.44, 0.85, 0);
    armR.position.set( 0.44, 0.85, 0);

    // Legs
    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.6, 0.22),
      new THREE.MeshStandardMaterial({ color: legCol, roughness: 0.5, metalness: 0.05 }));
    const legR = legL.clone();
    legL.position.set(-0.18, 0.3, 0);
    legR.position.set( 0.18, 0.3, 0);

    playerGroup.add(body, head, eyeL, eyeR, hairCap, hairStripe, backEyeL, backEyeR, armL, armR, legL, legR);
    scene.add(playerGroup);

    // Shadow
    const shadow = new THREE.Mesh(
      new THREE.CircleGeometry(0.6, 24),
      new THREE.MeshBasicMaterial({ color: 0x000000, transparent:true, opacity:0.25 })
    );
    shadow.rotation.x = -Math.PI/2;
    scene.add(shadow);

    // Player extents for landing
    const playerHalf = { x: 0.3, y: 0.8, z: 0.3 };

    // ------- Platforms -------
    const platforms = [];
    const platMatA = new THREE.MeshStandardMaterial({ color: 0x69e08a, roughness: 0.5, metalness: 0.05 });
    const platMatB = new THREE.MeshStandardMaterial({ color: 0x52b8f2, roughness: 0.5, metalness: 0.05 });
    const mats = [platMatA, platMatB];

    function makePlatform(w=2, h=0.3, d=2, x=0, y=0, z=0, mat=platMatA){
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat.clone());
      mesh.position.set(x, y, z);
      mesh.userData = { w, h, d };
      scene.add(mesh);
      platforms.push(mesh);
      return mesh;
    }

    // Long start platform + FORCED BIG GAP after it
    const startPlat = makePlatform(4.0, 0.3, 8.0, 0, 0.6, 0, platMatA);
    let seedZ = -16; // start next platforms well beyond the first (-8 front edge - big gap)

    function addChunk(n=8){
      for(let i=0;i<n;i++){
        const w = THREE.MathUtils.randFloat(1.4, 3.0);
        const d = THREE.MathUtils.randFloat(1.8, 2.5);
        const y = THREE.MathUtils.randFloat(0.6, 1.6);
        const x = THREE.MathUtils.randFloatSpread(2.2);
        seedZ -= THREE.MathUtils.randFloat(2.8, 4.8);
        const mat = mats[(Math.random()*mats.length)|0];
        makePlatform(w, 0.3, d, x, y, seedZ, mat);
      }
    }
    addChunk(14);

    // ------- State -------
    const state = {
      running:false,
      score:0,
      best: parseInt(localStorage.getItem('obby3d_best') || '0',10),
      zSpeed: 3.6,
      gravity: -20,
      jumpVelocity: 8.9,
      vy: 0,
      x: 0, y: 0, z: 3.0,
      onPlatform: true,
      lastTime: 0,
      legPhase: 0
    };

    // HUD
    const scoreEl = document.getElementById('score');
    const bestEl  = document.getElementById('best');
    bestEl.textContent = String(state.best);

    // Overlay controls
    const overlay = document.getElementById('overlay');
    const playBtn = document.getElementById('playBtn');
    const restartBtn = document.getElementById('restartBtn');
    const howBtn = document.getElementById('howBtn');
    const summary = document.getElementById('summary');
    const shareBtn= document.getElementById('shareBtn');

    function showOverlay(msg, withRestart=false){
      summary.textContent = msg;
      overlay.hidden = false;
      overlay.style.display = 'flex';
      overlay.style.pointerEvents = 'auto';
      playBtn.style.display = withRestart ? 'none' : 'inline-block';
      restartBtn.style.display = withRestart ? 'inline-block' : 'none';
    }
    function hideOverlay(){
      overlay.hidden = true;
      overlay.style.display = 'none';
      overlay.style.pointerEvents = 'none';
    }

    // Helpers
    const platformTopY = p => p.position.y + (p.userData.h || 0.3)/2 + 0.001;

    function placeOnStart(){
      state.x = 0;
      state.z = 3.0; // near the camera side of start platform
      state.y = platformTopY(startPlat) + playerHalf.y;
      state.vy = 0;
      state.onPlatform = true;
    }

    function resetGame(){
      state.running = true;
      state.score = 0; scoreEl.textContent = '0';
      state.zSpeed = 3.6; state.gravity = -20; state.jumpVelocity = 8.9;
      state.lastTime = performance.now();
      state.legPhase = 0;

      // Rebuild platforms keeping the big gap after start
      for (const p of platforms) scene.remove(p);
      platforms.length = 0;
      makePlatform(4.0, 0.3, 8.0, 0, 0.6, 0, platMatA);
      seedZ = -16; // ensure big gap
      addChunk(14);

      placeOnStart();
      hideOverlay();
    }

    function endGame(){
      state.running = false;
      if (state.score > state.best){
        state.best = state.score;
        localStorage.setItem('obby3d_best', String(state.best));
        bestEl.textContent = String(state.best);
      }
      showOverlay(`You fell! Score ${state.score}. Best ${state.best}.`, true);
    }

    function jump(){
      if(!state.running) return;
      if (state.onPlatform){
        state.vy = state.jumpVelocity;
        state.onPlatform = false;
      }
    }

    // Controls
    window.addEventListener('keydown', e=>{
      if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); jump(); }
    }, {passive:false});
    window.addEventListener('pointerdown', e=>{
      if (overlay.style.display !== 'none') return;
      jump();
    });

    playBtn.onclick = resetGame;
    restartBtn.onclick = resetGame;
    howBtn.onclick = () => alert("Tap/Space to jump.\nStart on a longer safe platform.\nThere is a BIG first gap now.\nReach the next platform to score.");

    // Share
    shareBtn.onclick = () => {
      const url = location.href;
      const msg = `I scored ${state.best} in Obby 3D — Mini! Play: ${url}`;
      location.href = `https://wa.me/?text=${encodeURIComponent(msg)}`;
    };

    // Camera follow
    function updateCamera(dt){
      const target = new THREE.Vector3(state.x, state.y + 2.2, state.z + 8.5);
      camera.position.lerp(target, Math.min(1, dt*2.5));
      camera.lookAt(state.x, state.y + 0.9, state.z - 2.0);
    }

    // STRICT landing: no padding beyond platform edges (prevents “air walk” past edge)
    function checkLanding(px, py, pz){
      let landed = false;
      const feetY = py - playerHalf.y;

      for (let i=0;i<platforms.length;i++){
        const p = platforms[i];
        const w = p.userData.w, h = p.userData.h, d = p.userData.d;
        const minX = p.position.x - w/2, maxX = p.position.x + w/2;
        const topY = p.position.y + h/2 + 0.001;
        const minZ = p.position.z - d/2, maxZ = p.position.z + d/2;

        // must be strictly within XZ bounds (no extra padding)
        const withinXZ = (px >= minX && px <= maxX && pz >= minZ && pz <= maxZ);

        if (withinXZ && state.vy <= 0){
          const tolerance = 0.32; // vertical snap window
          if (feetY <= topY + 0.02 && feetY >= (topY - tolerance)){
            state.y = topY + playerHalf.y;
            state.vy = 0;
            landed = true;
          }
        }

        // Score when we pass the platform's front edge (movement toward -Z)
        if (!p.userData.passed && pz < (minZ - 0.2)){
          p.userData.passed = true;
          state.score += 1; scoreEl.textContent = String(state.score);
          state.zSpeed = Math.min(7.5, state.zSpeed + 0.06);
          if ((state.score % 6) === 0) addChunk(6);
        }
      }
      return landed;
    }

    // Blockman anim
    function animateBlockMan(dt){
      state.legPhase += dt * (state.onPlatform ? (2.6 + state.zSpeed*0.35) : 6.0);
      const legSwing = state.onPlatform ? Math.sin(state.legPhase) * 0.55 : 0.12;
      const armSwing = state.onPlatform ? Math.sin(state.legPhase + Math.PI) * 0.65 : 0.18;
      const bob      = state.onPlatform ? Math.abs(Math.sin(state.legPhase))*0.035 : 0.0;

      body.position.y = 0.8 + bob;
      head.position.y = 1.35 + bob * 0.6;

      armL.rotation.x = armSwing;
      armR.rotation.x = -armSwing;
      legL.rotation.x = legSwing;
      legR.rotation.x = -legSwing;

      const targetTilt = state.onPlatform ? 0.08 : -0.05;
      playerGroup.rotation.x = THREE.MathUtils.lerp(playerGroup.rotation.x, targetTilt, 0.15);
    }

    // Main loop
    function animate(now){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, (now - (state.lastTime||now))/1000);
      state.lastTime = now;

      if (state.running){
        state.z -= state.zSpeed * dt;
        state.vy += state.gravity * dt;
        state.y += state.vy * dt;

        const wasOn = state.onPlatform;
        state.onPlatform = checkLanding(state.x, state.y, state.z);

        // If we stepped off the edge this frame, ensure we start falling
        if (wasOn && !state.onPlatform && state.vy >= 0) {
          state.vy = -0.01; // nudge downward so we don't "hover" a frame
        }

        if (!state.onPlatform && state.y < -4) endGame();

        // Cull far-behind platforms
        for (let i=platforms.length-1; i>=0; i--){
          if (platforms[i].position.z - state.z > 120){
            scene.remove(platforms[i]);
            platforms.splice(i,1);
          }
        }
      }

      playerGroup.position.set(state.x, state.y, state.z);
      animateBlockMan(dt);

      shadow.position.set(state.x, Math.max(0.05, state.y-0.85), state.z);
      const shadowScale = Math.max(0.35, 1.1 - (state.y-0.6)*0.25);
      shadow.scale.set(shadowScale, shadowScale, 1);

      updateCamera(dt);
      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);

    // Responsive
    window.addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    placeOnStart();
    showOverlay("Long start platform + BIG first gap. Tap/Space to jump and reach the next platforms!");
  </script>
</body>
</html>
