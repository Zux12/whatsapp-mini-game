<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Obby 3D — Mini</title>

  <!-- Social preview -->
  <meta property="og:title" content="Obby 3D — Mini" />
  <meta property="og:description" content="Tap/Space to jump across floating platforms. How far can you go?" />
  <meta property="og:image" content="https://zux12.github.io/whatsapp-mini-game/preview.png" />
  <meta property="og:url" content="https://zux12.github.io/whatsapp-mini-game/" />
  <meta name="twitter:card" content="summary_large_image" />

  <link rel="icon" href="favicon.ico" />

  <style>
    :root { --bg:#0e1024; --fg:#e9ecff; --muted:#8b90b6; --accent:#69e08a; }
    html,body{height:100%; margin:0; background:#0e1024; color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial,sans-serif; overflow:hidden;}
    /* Safari-safe hide */
    [hidden]{ display:none !important; }

    #hud{
      position:fixed; inset:0; pointer-events:none; display:flex; flex-direction:column; justify-content:space-between;
      padding:12px;
    }
    .topbar{display:flex; gap:8px; align-items:center; justify-content:space-between;}
    .pill{pointer-events:auto; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); padding:8px 12px; border-radius:999px; font-variant-numeric:tabular-nums;}
    .btn{pointer-events:auto; border:0; padding:12px 16px; border-radius:12px; cursor:pointer; font-weight:700; background:var(--accent); color:#072114; box-shadow:0 10px 24px rgba(106,224,138,.35);}
    .btn.secondary{background:#2d335e; color:#dfe3ff; box-shadow:none}

    #overlay{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:linear-gradient(180deg, rgba(10,12,30,.72), rgba(10,12,30,.55));
      backdrop-filter: blur(4px);
      z-index: 10;
    }
    .card{
      width:min(92vw,540px); border-radius:20px; padding:16px; text-align:center;
      background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12);
      box-shadow:0 20px 60px rgba(0,0,0,0.45);
    }
    h1{margin:8px 0 6px; font-size:22px}
    p{margin:8px 0; color:var(--muted)}
    .row{display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:10px}
    #hint{font-size:13px}
  </style>
</head>
<body>
  <div id="hud">
    <div class="topbar">
      <div class="pill">Score: <b id="score">0</b></div>
      <div class="pill">Best: <b id="best">0</b></div>
      <div class="pill">Tap/Space = Jump</div>
    </div>
    <div style="display:flex; gap:8px; justify-content:center; margin-bottom:10px;">
      <button id="shareBtn" class="btn secondary">Share my score</button>
    </div>
  </div>

  <div id="overlay">
    <div class="card">
      <h1>Obby 3D — Mini</h1>
      <p id="summary">Jump across floating platforms. Don’t fall!</p>
      <div class="row">
        <button id="playBtn" class="btn">▶️ Play</button>
        <button id="restartBtn" class="btn" style="display:none">↻ Restart</button>
        <button id="howBtn" class="btn secondary">How to play</button>
      </div>
      <p id="hint">Tap anywhere or press Space to jump. Reach farther platforms to gain score.</p>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

    // ------- Scene -------
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 4.5, 10);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.HemisphereLight(0xcad8ff, 0x202535, 1.25));
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(5,8,2);
    scene.add(dir);

    // ------- Sky (gradient skydome via simple shader) -------
    const skyUniforms = {
      topColor:    { value: new THREE.Color(0x0b0f2f) }, // zenith deep blue
      bottomColor: { value: new THREE.Color(0x565cf2) }, // horizon violet/indigo
    };
    const sky = new THREE.Mesh(
      new THREE.SphereGeometry(500, 32, 20),
      new THREE.ShaderMaterial({
        uniforms: skyUniforms,
        vertexShader: `
          varying vec3 vWorldPosition;
          void main(){
            vec4 wp = modelMatrix * vec4(position, 1.0);
            vWorldPosition = wp.xyz;
            gl_Position = projectionMatrix * viewMatrix * wp;
          }`,
        fragmentShader: `
          varying vec3 vWorldPosition;
          uniform vec3 topColor;
          uniform vec3 bottomColor;
          void main(){
            // Map world Y into 0..1 range (horizon ≈ y=0)
            float h = clamp((vWorldPosition.y + 20.0) / 80.0, 0.0, 1.0);
            vec3 col = mix(bottomColor, topColor, smoothstep(0.0, 1.0, h));
            gl_FragColor = vec4(col, 1.0);
          }`,
        side: THREE.BackSide,
        depthWrite: false
      })
    );
    scene.add(sky);

    // ------- Sea (big waving plane) -------
    const seaUniforms = {
      time: { value: 0 },
      baseColor: { value: new THREE.Color(0x1341a1) }, // deep blue
      foamColor: { value: new THREE.Color(0x88c1ff) }  // highlight
    };
    const sea = new THREE.Mesh(
      // Segments kept moderate for mobile performance; increase for smoother waves
      new THREE.PlaneGeometry(1000, 1000, 128, 128),
      new THREE.ShaderMaterial({
        uniforms: seaUniforms,
        vertexShader: `
          uniform float time;
          varying vec2 vUv;
          varying float vHeight;
          void main(){
            vUv = uv;
            vec3 pos = position;
            // Two gentle sine waves (pre-rotation)
            float w1 = sin((pos.x * 0.06) + time * 0.8) * 0.25;
            float w2 = cos((pos.y * 0.05) - time * 0.55) * 0.20;
            pos.z += w1 + w2;   // "z" here becomes "y" after we rotate plane below
            vHeight = w1 + w2;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
          }`,
        fragmentShader: `
          uniform vec3 baseColor;
          uniform vec3 foamColor;
          varying vec2 vUv;
          varying float vHeight;
          void main(){
            // Color blend based on wave crest for a subtle shimmer
            float f = smoothstep(-0.25, 0.35, vHeight);
            vec3 col = mix(baseColor, foamColor, f * 0.25);
            gl_FragColor = vec4(col, 1.0);
          }`,
        transparent: false
      })
    );
    sea.rotation.x = -Math.PI / 2; // lay flat on XZ
    sea.position.y = -5;           // below platforms
    scene.add(sea);

    // ------- Player: Sphere -------
    const playerRadius = 0.4;
    const player = new THREE.Mesh(
      new THREE.SphereGeometry(playerRadius, 24, 20),
      new THREE.MeshStandardMaterial({ color: 0xe6e7ff, roughness: 0.4, metalness: 0.0 })
    );
    scene.add(player);

    // Shadow (fake)
    const shadow = new THREE.Mesh(
      new THREE.CircleGeometry(0.55, 24),
      new THREE.MeshBasicMaterial({ color: 0x000000, transparent:true, opacity:0.25 })
    );
    shadow.rotation.x = -Math.PI/2;
    scene.add(shadow);

    // ------- Platforms & helpers -------
    const platforms = [];
    const platMatA = new THREE.MeshStandardMaterial({ color: 0x69e08a, roughness: 0.5, metalness: 0.05 });
    const platMatB = new THREE.MeshStandardMaterial({ color: 0x52b8f2, roughness: 0.5, metalness: 0.05 });
    const mats = [platMatA, platMatB];

    function makePlatform(w=2, h=0.3, d=2, x=0, y=0, z=0, mat=platMatA){
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat.clone());
      mesh.position.set(x, y, z);
      mesh.userData = { w, h, d };
      scene.add(mesh);
      platforms.push(mesh);
      return mesh;
    }
    function makePlatformByEdges(width, height, backEdgeZ, frontEdgeZ, x, y, mat){
      const d = Math.abs(backEdgeZ - frontEdgeZ);
      const centerZ = (backEdgeZ + frontEdgeZ) / 2;
      return makePlatform(width, height, d, x, y, centerZ, mat);
    }
    const frontEdgeOf = p => p.position.z - p.userData.d/2; // towards -Z
    const backEdgeOf  = p => p.position.z + p.userData.d/2; // towards +Z
    const topYOf      = p => p.position.y + (p.userData.h || 0.3)/2 + 0.001;

    // ------- Physics / State -------
    const state = {
      running:false,
      score:0,
      best: parseInt(localStorage.getItem('obby3d_best') || '0',10),
      zSpeed: 3.6,
      gravity: -20,
      jumpVelocity: 8.6,
      vy: 0,
      x: 0, y: 0, z: 2.0,
      onPlatform: true,
      lastTime: 0
    };
    const MAX_GAP = state.zSpeed * (2*state.jumpVelocity/Math.abs(state.gravity)) - 0.4; // ~2.7 safe
    const SAFE_GAP_MIN = 1.6, SAFE_GAP_MAX = Math.min(2.6, MAX_GAP);

    // ------- Level layout (safe first jumps) -------
    const startPlat = makePlatform(3.2, 0.3, 6.0, 0, 0.6, 0, platMatA);   // front ≈ -3.0
    const gap1 = 2.0;
    const firstBack = frontEdgeOf(startPlat) - gap1;
    const firstDepth = 2.2;
    const firstFront = firstBack - firstDepth;
    const firstPlat = makePlatformByEdges(2.4, 0.3, firstBack, firstFront, 0.0, 1.0, platMatB);

    const gap2 = 2.2;
    const secondBack = frontEdgeOf(firstPlat) - gap2;
    const secondDepth = 2.2;
    const secondFront = secondBack - secondDepth;
    const secondPlat = makePlatformByEdges(2.2, 0.3, secondBack, secondFront, 0.1, 1.05, platMatA);

    let lastFront = frontEdgeOf(secondPlat);
    function addChunk(n=12){
      for (let i=0;i<n;i++){
        const gap = THREE.MathUtils.randFloat(SAFE_GAP_MIN, SAFE_GAP_MAX);
        const w = THREE.MathUtils.randFloat(1.6, 3.0);
        const d = THREE.MathUtils.randFloat(1.8, 2.5);
        const y = THREE.MathUtils.randFloat(0.6, 1.5);
        const x = THREE.MathUtils.randFloatSpread(2.0);

        const backEdge = lastFront - gap;
        const frontEdge = backEdge - d;
        const mat = mats[(Math.random()*mats.length)|0];
        const p = makePlatformByEdges(w, 0.3, backEdge, frontEdge, x, y, mat);

        lastFront = frontEdgeOf(p);
      }
    }
    addChunk(14);

    // ------- HUD / overlay -------
    const scoreEl = document.getElementById('score');
    const bestEl  = document.getElementById('best');
    bestEl.textContent = String(state.best);

    const overlay = document.getElementById('overlay');
    const playBtn = document.getElementById('playBtn');
    const restartBtn = document.getElementById('restartBtn');
    const howBtn = document.getElementById('howBtn');
    const summary = document.getElementById('summary');
    const shareBtn= document.getElementById('shareBtn');

    function showOverlay(msg, withRestart=false){
      summary.textContent = msg;
      overlay.hidden = false;
      overlay.style.display = 'flex';
      overlay.style.pointerEvents = 'auto';
      playBtn.style.display = withRestart ? 'none' : 'inline-block';
      restartBtn.style.display = withRestart ? 'inline-block' : 'none';
    }
    function hideOverlay(){
      overlay.hidden = true;
      overlay.style.display = 'none';
      overlay.style.pointerEvents = 'none';
    }

    function placeOnStart(){
      state.x = 0;
      state.z = 2.0;
      state.y = topYOf(startPlat) + playerRadius;
      state.vy = 0;
      state.onPlatform = true;
    }

    function rebuildLevel(){
      for (const p of platforms) scene.remove(p);
      platforms.length = 0;

      const s = makePlatform(3.2, 0.3, 6.0, 0, 0.6, 0, platMatA);
      const g1 = 2.0, fd = 2.2;
      const fb = frontEdgeOf(s) - g1;
      const ff = fb - fd;
      const f = makePlatformByEdges(2.4, 0.3, fb, ff, 0.0, 1.0, platMatB);

      const g2 = 2.2, sd = 2.2;
      const sb = frontEdgeOf(f) - g2;
      const sf = sb - sd;
      const sp = makePlatformByEdges(2.2, 0.3, sb, sf, 0.1, 1.05, platMatA);

      lastFront = frontEdgeOf(sp);
      addChunk(14);
    }

    function resetGame(){
      state.running = true;
      state.score = 0; scoreEl.textContent = '0';
      state.zSpeed = 3.6; state.gravity = -20; state.jumpVelocity = 8.6;
      state.lastTime = performance.now();

      rebuildLevel();
      placeOnStart();
      hideOverlay();
    }

    function endGame(){
      state.running = false;
      if (state.score > state.best){
        state.best = state.score;
        localStorage.setItem('obby3d_best', String(state.best));
        bestEl.textContent = String(state.best);
      }
      showOverlay(`You fell into the sea! 🌊 Score ${state.score}. Best ${state.best}.`, true);
    }

    function jump(){
      if(!state.running) return;
      if (state.onPlatform){
        state.vy = state.jumpVelocity;
        state.onPlatform = false;
      }
    }

    // Controls
    window.addEventListener('keydown', e=>{
      if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); jump(); }
    }, {passive:false});
    window.addEventListener('pointerdown', e=>{
      if (overlay.style.display !== 'none') return;
      jump();
    });

    playBtn.onclick = resetGame;
    restartBtn.onclick = resetGame;
    howBtn.onclick = () => alert("Tap/Space to jump.\nFall into the sea to end the run.\nGaps are capped early so each jump is reachable.");

    // Share
    shareBtn.onclick = () => {
      const url = location.href;
      const msg = `I scored ${state.best} in Obby 3D — Mini! Play: ${url}`;
      location.href = `https://wa.me/?text=${encodeURIComponent(msg)}`;
    };

    // Camera follow
    function updateCamera(dt){
      const target = new THREE.Vector3(state.x, state.y + 2.2, state.z + 8.5);
      camera.position.lerp(target, Math.min(1, dt*2.5));
      camera.lookAt(state.x, state.y + 0.6, state.z - 2.0);
    }

    // Sphere-over-box landing
    function checkLanding(cx, cy, cz){
      let landed = false;
      const feetY = cy - playerRadius;

      for (let i=0;i<platforms.length;i++){
        const p = platforms[i];
        const w = p.userData.w, h = p.userData.h, d = p.userData.d;
        const minX = p.position.x - w/2, maxX = p.position.x + w/2;
        const topY = p.position.y + h/2 + 0.001;
        const minZ = p.position.z - d/2, maxZ = p.position.z + d/2;

        // Strict within-bounds check (prevents edge hovering)
        const withinXZ = (cx >= minX && cx <= maxX && cz >= minZ && cz <= maxZ);

        if (withinXZ && state.vy <= 0){
          const tolerance = 0.32; // vertical snap window
          if (feetY <= topY + 0.02 && feetY >= (topY - tolerance)){
            state.y = topY + playerRadius;
            state.vy = 0;
            landed = true;
          }
        }

        // Score when passing front edge
        if (!p.userData.passed && cz < (p.position.z - d/2 - 0.2)){
          p.userData.passed = true;
          state.score += 1; scoreEl.textContent = String(state.score);
          state.zSpeed = Math.min(7.5, state.zSpeed + 0.06);
          if ((state.score % 6) === 0) addChunk(6);
        }
      }
      return landed;
    }

    // Main loop
    function animate(now){
      requestAnimationFrame(animate);
      const dt = Math.min(0.033, (now - (state.lastTime||now))/1000);
      state.lastTime = now;

      // Update sea animation
      seaUniforms.time.value += dt;

      if (state.running){
        state.z -= state.zSpeed * dt;
        state.vy += state.gravity * dt;
        state.y += state.vy * dt;

        const wasOn = state.onPlatform;
        state.onPlatform = checkLanding(state.x, state.y, state.z);

        if (wasOn && !state.onPlatform && state.vy >= 0) {
          state.vy = -0.02; // nudge to start falling immediately after edge
        }

        // Fall into sea → game over
        if (!state.onPlatform && state.y < -4) endGame();

        // Cull far-behind platforms (perf)
        for (let i=platforms.length-1; i>=0; i--){
          if (platforms[i].position.z - state.z > 120){
            scene.remove(platforms[i]);
            platforms.splice(i,1);
          }
        }
      }

      // Mesh transforms
      player.position.set(state.x, state.y, state.z);
      player.rotation.z += state.running ? 0.02 + state.zSpeed*0.002 : 0.0;

      shadow.position.set(state.x, Math.max(0.05, state.y-0.45), state.z);
      const shadowScale = Math.max(0.35, 1.0 - (state.y-0.6)*0.25);
      shadow.scale.set(shadowScale, shadowScale, 1);

      updateCamera(dt);
      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);

    // Responsive
    window.addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    placeOnStart();
    showOverlay("New look: sky gradient + sea below 🌅🌊 Tap/Space to play!");
  </script>
</body>
</html>
